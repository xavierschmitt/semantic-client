# DESCRIPTION:
#   - fact base for semantic client knowledge engine
#   - contains information about facts the engine should know in order to assemble and perform operations
# NOTES:
#   - when a given system registers itself and its functions with this meta-client/knowledge system, it must
#     tell the knowledge system
#       - system information - system name, etc.
#       - function information - what functions it supports and how they are defined, assembled, etc.
#   - user queries and tasks we need to ask the knowledge engine to do will entail asking it
#       - to answer-questions (i.e., find configurations of facts about systems and functions)
#         so it can determine
#           - what it needs to do - i.e., identify what function must be called
#           - who needs to do it  - i.e., what system(s) can support that function
#           - what information they need to do it - i.e., do we have all the right inputs, are they the right type?
#           - what information to provide to systems to execute it
#           - what the results are

# what users do we have?
user(user1)
user(user2)

# what do they want to do?
# - a user should be able to specify some details/facts (that the knowledge engine may know) regarding:
#   - what they want to do
#   - what goal they want to achieve
#   - what information is available


# what should the knowledge engine be able to do?
# - in turn, the knowledge engine should be able to
#   - determine if it can
#       - understand clearly user's goal (did the user provide enough information/facts to find at least one way
#         to solve the problem?)
#           - if not, can we:
#               - determine what other kinds of information we're missing (we need)?
#               - ask user for the rest of the info?
#       - find 1+ ways to reach-that-goal/handle-that-request
#       - decide how to select one (or many) ways to handle the request
#       - ask the systems with those functions to perform them
#       - return results to user

# NOTE:
#   - Below the facts are shown as a way to show how various facts are organized together.
#   - However, a given system or user might specify facts grouped in a more object-centric fashion to
#     specify all the facts with a given object at once - such as:
#       system(mdcs)
#           has_fx(mdcs, addstr)
#       function(addstr)
#           is_type(addstr, add)
#           has_in_arity(addstr, 2)
#           has_out_arity(addstr,1)
#           has_in_arg(addstr,1,STR)
#           has_in_arg(addstr,2,STR)
#           has_out_arg(addstr,1,STR)
#   - same thing with a user query:
#       user(user1)
#           function(add)?
#               is_type(X, add)?
#               has_in_arg(X, 1, STR)?
#               has_in_arg(X, 2, STR)?

# what systems can support functions?
#system(sys_name)
system(mdcs)
system(ht)
system(mc)

# what functions does a given support?
#has_fx(sys_name, fx_name)
has_fx(mdcs, addstr)
has_fx(mc, addstr)
has_fx(ht, addint)

# what functions can be performed across any system?
#function(fx_name)
function(addstr)
function(addint)

# what type of function is a given function?
#is_type(fx_name, fx_type)
is_type(addstr, add)
is_type(addint, add)

# how is a given function defined?
# - a given function must, at minimum, provide information about
#    - its name
#    - its arities/cardinalities = numbers of inputs, outputs (and total=#inputs + #outputs)
#    - its signature = its respective input/output argument and type

# function(addstr)
has_in_arity(addstr, 2)
has_out_arity(addstr, 1)
has_in_arg(addstr,1,STR)
has_in_arg(addstr,2,STR)
has_out_arg(addstr,1,STR)

# function(addint)
has_in_arity(addint, 2)
has_out_arity(addint, 1)
has_in_arg(addint,1,INT)
has_in_arg(addint,2,INT)
has_out_arg(addint,1,INT)

# what variable types can be used for function inputs or outputs?
var_type(STR)
var_type(INT)

# what constant values exist in the system?
const(2)
const(3)
const(5)
const(a)
const(b)
const(ab)

# what are the types of the constants?
# const_type(c_value, c_type)
const_type(2,INT)
const_type(3,INT)
const_type(5,INT)
const_type(a,STR)
const_type(b,STR)
const_type(ab,STR)

# what general functional types do I have?
gen_type(FX)
has_in_arity(FX, N)
has_out_arity(FX, N)
has_in_arg(addint,1,INT)
has_in_arg(addint,2,INT)
has_out_arg(addint,1,INT)

gen_type(VAR)
gen_type(CONST)
gen_type(ASSIGN)



# what types are compatible with each other?
#is_compatible_with(type1,type2)
is_compatible_with(STR,STR)
is_compatible_with(INT,INT)

# how is each function assembled?

# assemble addint by
#    - const_type(2,INT)
#        - matches_type: